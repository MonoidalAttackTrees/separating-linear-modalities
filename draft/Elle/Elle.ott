% Input variables.
metavar vars ,  n , a, x , y, z , w , m , o ::=  
indexvar ivar, i , k , j , l ::=
metavar const, b ::= 

grammar


% Lambek category:
A, B, C :: 'lform_' ::=
  | Base    ::   :: Base          {{com Base type }}
  {{tex \mathsf{B} }}
  | Unit    ::   :: Unit          {{com Unit }}
  | A (x) B ::   :: Tensor        {{com Non-commutative tensor }}
  | A -> B  ::   :: RFun          {{com Left implication }}
  | A <- B  ::   :: LFun          {{com Right implication }}  
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}

% Symmetric monoidal closed category:
X, Y, Z :: 'sform_' ::=
  | Base    ::   :: Base          {{com Base type }}
  {{tex \mathsf{B} }}
  | Unit    ::   :: Unit          {{com Unit }}
  | X (x) Y ::   :: Tensor        {{com Non-commutative tensor }}
  | X -> Y  ::   :: RFun          {{com implication }}
  | ( X )   :: M :: Parens 
  | h( X )  :: M :: HiddenParens 
  {{ tex [[X]] }}

p :: 'pattern_' ::=
  | - :: :: hole
  {{tex \star }}
  | x :: :: var
  | p (x) p' :: :: ten  

t :: 'term_' ::=
  | x :: :: Var
  | b :: :: Const
  | unit :: :: Unit
  {{tex \mathsf{unit} }}
  | let t1 : A be p in t2 :: :: let
  {{tex \mathsf{let}\,[[t1]] : [[A]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[t2]] }}
  | t1 (x) t2 :: :: Tensor
  | \l x : A . t :: :: LFun
  {{tex \lambda_l [[x]] : [[A]].[[t]] }}
  | \r x : A . t :: :: RFun
  {{tex \lambda_r [[x]] : [[A]].[[t]] }}
  | \ x : A . t :: :: Fun
  {{tex \lambda [[x]] : [[A]].[[t]] }}  
  | appl t1 t2   :: :: Appl
  {{tex \mathsf{app}_l\,[[t1]]\,[[t2]] }}
  | appr t1 t2   :: :: Appr
  {{tex \mathsf{app}_r\,[[t1]]\,[[t2]] }}
  | app t1 t2   :: :: App
  {{tex \mathsf{app}\,[[t1]]\,[[t2]] }}  
  | ex x1 , x2 with t1 , t2 in t3 :: :: Ex
  {{tex \mathsf{ex}\,[[x1]],[[x2]]\,\mathsf{with}\,[[t1]],[[t2]]\,\mathsf{in}\,[[t3]] }}
  | [ t1 / x ] t2 :: M :: Subst

G {{tex \Gamma}}, D {{tex \Delta}}, I {{tex \Phi}}, P {{tex \Psi}} :: 'Ctx_' ::=
  | .       :: :: Empty
  {{tex \cdot }}
  | G1 , G2 :: :: Ext
  | x : A   :: :: El
  | ( G )   :: S :: Paren
  | x : X   ::   :: EParen

formula :: 'formula_' ::=
  | judgement            ::   :: judgement
  | formula1 && formula2 :: M :: quad
  {{tex [[formula1]] \quad [[formula2]] }}
  | formula1 ... formulai :: M :: vec
  | ( formula )          :: S :: parens
  {{tex [[formula]] }}
  | x nin FV ( t ) :: :: FV
  {{tex [[x]] \not\in \mathsf{FV}([[t]]) }}

terminals :: 'terminals_' ::=
  | Unit :: :: Unit
  {{tex \mathsf{Unit} }}
  | (x)  :: :: Tensor
  {{tex \otimes }}
  | (e)  :: :: ETensor
  {{tex \circop{e} }}  
  | (w)  :: :: WTensor
  {{tex \circop{w} }}  
  | (c)  :: :: CTensor
  {{tex \circop{c} }}
  | ->   :: :: LFun
  {{tex \rightharpoonup }}
  | <-   :: :: RFun
  {{tex \leftharpoonup }}
  | -o   :: :: Limp
  {{tex \multimap }}
  | |-   :: :: Vdash
  {{tex \vdash }}
 
defns
  Jtype :: '' ::=

defn
  G |- t : A :: :: sty :: 'S_'
by 

  -------------- :: var
  x : A |- x : A

  G, x : A, y : B,D |- t : C
  --------------------------------------------- :: beta
  G, z : B, w : A,D |- ex w,z with x,y in t : C

  G |- t1 : A && D1,x : A,D2 |- t2 : B
  ------------------------------------ :: cut
  D1,G,D2 |- [t1/x]t2 : B

  G,x : A,D |- t : C
  ------------------------------------------------------ :: tenL1
  G,y : A (x) B,D |- let y : A (x) B be x (x) - in t : C

  G,x : B,D |- t : C
  ------------------------------------------------------ :: tenL2
  G,y : A (x) B,D |- let y : A (x) B be - (x) x in t : C

  G |- t1 : A && D |- t2 : B
  -------------------------- :: ten
  G,D |- t1 (x) t2 : A (x) B  

  

defn
  G ; P |- t : A :: :: lty :: 'L_'
by