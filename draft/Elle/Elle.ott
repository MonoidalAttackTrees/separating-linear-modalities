% Input variables.
metavar vars ,  n , a, x , y, z , w , m , o ::=  
indexvar ivar, i , k , j , l ::=
metavar const, b ::= 

grammar


% Lambek category:
A, B, C :: 'lform_' ::=
  | Base    ::   :: Base          
  {{tex \mathsf{B} }}
  | Unit    ::   :: Unit
  {{tex \mathsf{Unit} }}
  | A (x) B ::   :: Tensor        
  | A -> B  ::   :: RFun          
  | A <- B  ::   :: LFun          
  | ( A )   :: M :: Parens 
  | h( A )  :: M :: HiddenParens 
  {{ tex [[A]] }}
  | F X     ::   :: LeftAdj
  {{tex \mathsf{F}[[X]] }}

% Symmetric monoidal closed category:
X, Y, Z :: 'sform_' ::=
  | Base    ::   :: Base          
  {{tex \mathsf{B} }}
  | Unit    ::   :: Unit
  {{tex \mathsf{Unit} }}
  | X (x) Y ::   :: Tensor        
  | X -> Y  ::   :: LFun          
  | X <- Y  ::   :: RFun          
  | ( X )   :: M :: Parens 
  | h( X )  :: M :: HiddenParens 
  {{ tex [[X]] }}
  | Gf A     ::   :: RightAdj
  {{tex \mathsf{G}[[A]] }}

T :: 'type_' ::=
  | A :: :: LType
  | X :: :: SType

p :: 'pattern_' ::=
  | - :: :: hole
  {{tex \star }}
  | x :: :: var
  | triv :: :: triv
  {{tex \mathsf{triv} }}
  | p (x) p' :: :: ten
  | F p :: :: LeftAdj
  {{tex \mathsf{F}\,[[p]] }}
  | Gf p     ::   :: RightAdj
  {{tex \mathsf{G}\,[[p]] }}

s :: 'term_' ::=
  | x :: :: Var
  | b :: :: Const
  | triv :: :: Unit
  {{tex \mathsf{triv} }}
  | let s1 : T be p in s2 :: :: let
  {{tex \mathsf{let}\,[[s1]] : [[T]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[s2]] }}
  | s1 (x) s2 :: :: Tensor
  | \l x : A . s :: :: LFun
  {{tex \lambda_l [[x]] : [[A]].[[s]] }}
  | \r x : A . s :: :: RFun
  {{tex \lambda_r [[x]] : [[A]].[[s]] }}
  | \ x : A . s :: :: Fun
  {{tex \lambda [[x]] : [[A]].[[s]] }}  
  | appl s1 s2   :: :: Appl
  {{tex \mathsf{app}_l\,[[s1]]\,[[s2]] }}
  | appr s1 s2   :: :: Appr
  {{tex \mathsf{app}_r\,[[s1]]\,[[s2]] }}
  | app s1 s2   :: :: App
  {{tex \mathsf{app}\,[[s1]]\,[[s2]] }}  
  | ex x1 , x2 with s1 , s2 in s3 :: :: Ex
  {{tex \mathsf{ex}\,[[x1]],[[x2]]\,\mathsf{with}\,[[s1]],[[s2]]\,\mathsf{in}\,[[s3]] }}
  | contrR x1 as s1 , s2 in s3 :: :: ContrR
  {{tex \mathsf{contrR}\,[[x1]]\,\mathsf{as}\,[[s1]],[[s2]]\,\mathsf{in}\,[[s3]] }}
  | contrL x1 as s1 , s2 in s3 :: :: ContrL
  {{tex \mathsf{contrL}\,[[x1]]\,\mathsf{as}\,[[s1]],[[s2]]\,\mathsf{in}\,[[s3]] }}
  | weak x in s :: :: Weak
  {{tex \mathsf{weak}\,[[x]]\,\mathsf{in}\,[[s]] }}
  | [ s1 / x ] s2 :: M :: Subst
  | [ t / x ] s   :: M :: Subst2
  | ( s )         :: S :: parens
  | h( s )        :: M :: hparen
  {{tex [[s]] }}
  | F t           ::   :: LeftAdj
  {{tex \mathsf{F}[[t]] }}

t :: 'sterm_' ::=
  | x :: :: Var
  | b :: :: Const
  | triv :: :: Unit
  {{tex \mathsf{triv} }}
  | let t1 : X be p in t2 :: :: let
  {{tex \mathsf{let}\,[[t1]] : [[X]]\,\mathsf{be}\,[[p]]\,\mathsf{in}\,[[t2]] }}
  | t1 (x) t2 :: :: Tensor
  | \l x : X . t :: :: LFun
  {{tex \lambda_l [[x]] : [[X]].[[t]] }}
  | \r x : X . t :: :: RFun
  {{tex \lambda_r [[x]] : [[X]].[[t]] }}
  | \ x : X . t :: :: Fun
  {{tex \lambda [[x]] : [[X]].[[t]] }}  
  | appl t1 t2   :: :: Appl
  {{tex \mathsf{app}_l\,[[t1]]\,[[t2]] }}
  | appr t1 t2   :: :: Appr
  {{tex \mathsf{app}_r\,[[t1]]\,[[t2]] }}
  | app t1 t2   :: :: App
  {{tex \mathsf{app}\,[[t1]]\,[[t2]] }}  
  | ex x1 , x2 with t1 , t2 in t3 :: :: Ex
  {{tex \mathsf{ex}\,[[x1]],[[x2]]\,\mathsf{with}\,[[t1]],[[t2]]\,\mathsf{in}\,[[t3]] }}
  | contrR x1 as t1 , t2 in t3 :: :: ContrR
  {{tex \mathsf{contrR}\,[[x1]]\,\mathsf{as}\,[[t1]],[[t2]]\,\mathsf{in}\,[[t3]] }}
  | contrL x1 as t1 , t2 in t3 :: :: ContrL
  {{tex \mathsf{contrL}\,[[x1]]\,\mathsf{as}\,[[t1]],[[t2]]\,\mathsf{in}\,[[t3]] }}
  | weak x in t :: :: Weak
  {{tex \mathsf{weak}\,[[x]]\,\mathsf{in}\,[[t]] }}  
  | [ t1 / x ] t2 :: M :: Subst
  | ( t )         :: S :: parens
  | h( t )        :: M :: hparen
  | Gf s           ::   :: RightAdj
  {{tex \mathsf{G}[[s]] }}

G {{tex \Gamma}}, D {{tex \Delta}}, I {{tex \Phi}}, P {{tex \Psi}} :: 'Ctx_' ::=
  | .       :: :: Empty
  {{tex \cdot }}
  | G1 , G2 :: :: Ext
  | x : A   :: :: El
  | ( G )   :: S :: Paren
  | x : X   ::   :: EParen

formula :: 'formula_' ::=
  | judgement            ::   :: judgement
  | formula1 && formula2 :: M :: quad
  {{tex [[formula1]] \quad [[formula2]] }}
  | formula1 ... formulai :: M :: vec
  | ( formula )          :: S :: parens
  {{tex [[formula]] }}
  | x nin FV ( s ) :: :: FV
  {{tex [[x]] \not\in \mathsf{FV}([[s]]) }}
  | x nin1 | G , D , P | :: :: NiNCtx1
  {{tex [[x]] \not\in | [[G]], [[D]], [[P]] | }}
  | x nin2 | G , D |     :: :: NiNCtx2
  {{tex [[x]] \not\in | [[G]], [[D]] | }}

terminals :: 'terminals_' ::=
  | Unit :: :: Unit
  {{tex \mathsf{Unit} }}
  | (x)  :: :: Tensor
  {{tex \otimes }}
  | (e)  :: :: ETensor
  {{tex \circop{e} }}  
  | (w)  :: :: WTensor
  {{tex \circop{w} }}  
  | (c)  :: :: CTensor
  {{tex \circop{c} }}
  | ->   :: :: LFun
  {{tex \rightharpoonup }}
  | <-   :: :: RFun
  {{tex \leftharpoonup }}
  | -o   :: :: Limp
  {{tex \multimap }}
  | |-   :: :: Vdash
  {{tex \vdash }}
 
defns
  Jtype :: '' ::=

defn
  G |- t : X :: :: tty :: 'T_'
by 

  -------------- :: var
  x : X |- x : X

  G,D |- t : X
  --------------------------------------------- :: unitL
  G,x : Unit,D |- let x : Unit be triv in t : X

  ---------------- :: unitR
  . |- triv : Unit

  G, x : X, y : Y,D |- t : Z
  --------------------------------------------- :: beta
  G, z : Y, w : X,D |- ex w,z with x,y in t : Z

  G1, x : X, G2, y : X, G3 |- t : Y
  --------------------------------------------- :: contrR
  G1, G2, z : X, G3 |- contrR z as x,y in t : Y

  G1, x : X, G2, y : X, G3 |- t : Y
  --------------------------------------------- :: contrL
  G1, z : X, G2, G3 |- contrL z as x,y in t : Y

  G, D |- t : Y && x nin2 |G,D|
  ------------------------------ :: weak
  G, x : X, D |- weak x in t : Y

  G |- t1 : X && D1,x : X,D2 |- t2 : Y
  ------------------------------------ :: cut
  D1,G,D2 |- [t1/x]t2 : Y

  G,x : X,y : Y,D |- t : Z
  ------------------------------------------------------ :: tenL
  G,z : X (x) Y,D |- let z : X (x) Y be x (x) y in t : Z

  G |- t1 : X && D |- t2 : Y
  -------------------------- :: ten
  G,D |- t1 (x) t2 : X (x) Y  

  G |- t1 : X && D1,x : Y,D2 |- t2 : Z
  ----------------------------------------- :: impLl
  D1,G,y : X -> Y,D2 |- [appl y t1/x]t2 : Z

  G |- t1 : X && D1,x : Y,D2 |- t2 : Z
  ----------------------------------------- :: impL2
  D1,y : Y <- X,G,D2 |- [appr y t1/x]t2 : Z

  G, x : X |- t : Y
  ---------------------- :: impRl
  G |- \l x:X.t : X -> Y

  x : X,G |- t : Y
  ---------------------- :: impRr
  G |- \r x:X.t : Y <- X

  G ; . |- s : A
  ---------------- :: Gr
  G |- Gf s : Gf A

defn
  G ; P |- s : A :: :: sty :: 'S_'
by

  ------------------ :: ax
  . ; x : A |- x : A

  G,D;P |- s : A
  ----------------------------------------------- :: unitl1
  G,x : Unit,D;P |- let x : Unit be triv in s : A

  G;P,I |- s : A
  ----------------------------------------------- :: unitl2
  G;P,x : Unit,I |- let x : Unit be triv in s : A

  -------------------- :: unitr
  . ; . |- triv : Unit

  G, x : X, y : Y,D;P |- s : A
  ----------------------------------------------- :: beta
  G, z : Y, w : X,D;P |- ex w,z with x,y in s : A

  G, D ; P |- s : B && x nin1 |G,D,P|
  ----------------------------------- :: weak
  G, x : X, D ; P |- weak x in s : B

  G1, x : X, G2, y : X, G3 ; P |- s : B
  ------------------------------------------------- :: contrR
  G1, G2, z : X, G3 ; P |- contrR z as x,y in s : B

  G1, x : X, G2, y : X, G3 ; P |- s : B
  ------------------------------------------------- :: contrL
  G1, z : X, G2, G3 ; P |- contrL z as x,y in s : B

  G |- t : X && D1,x : X,D2;P |- s : A
  ------------------------------------ :: cut1
  D1,G,D2;I |- [t/x]s : A

  G;P |- s1 : A && D;I1,x : A,I2 |- s2 : B
  ---------------------------------------- :: cut2
  G,D;I1,P,I2 |- [s1/x]s2 : B

  G,x : X,y : Y,D;P |- s : A
  -------------------------------------------------------- :: tenL1
  G,z : X (x) Y,D;P |- let z : X (x) Y be x (x) y in s : A

  G;P,x : A, y : B,I |- s : A
  -------------------------------------------------------- :: tenL2
  G;P,z : A (x) B,I |- let z : A (x) B be x (x) y in s : A

  G;P |- s1 : A && D;I |- s2 : B
  ------------------------------ :: tenR
  G,D;P,I |- s1 (x) s2 : A (x) B

  G |- t : X && D1,x : Y,D2;P |- s : A
  ----------------------------------------- :: impLl
  D1,G,y : X -> Y,D2;P |- [appl y t/x]s : A

  G |- t : X && D1,x : Y,D2;P |- s : A
  ------------------------------------------ :: impL2
  D1,y : Y <- X,G,D2;P |- [appr y t/x]s : A

  G;P |- s1 : A && D;I1,x : B,I2 |- s2 : A
  --------------------------------------------- :: impL3
  G,D;I1,P,y : A -> B,I2 |- [appl y s1/x]s2 : A

  G;P |- s1 : A && D;I1,x : B,I2 |- s2 : A
  --------------------------------------------- :: impL4
  G,D;I1,y : B <- A,P,I2 |- [appl y s1/x]s2 : A

  G;P,x : A |- s : B
  ------------------------ :: impRl
  G;P |- \l x:A.s : A -> B

  G;x : A,P |- s : B
  ------------------------ :: impRr
  G;P |- \r x:A.s : B <- A

  G |- t : X
  ---------------- :: Fr
  G;. |- F t : F X

  G,x : X;P |- s : A
  ------------------------------------------ :: Fl
  G;z : F X,P |- let z : F X be F x in s : A

  G;P,x : A |- s : B
  --------------------------------------------- :: Gl
  z : Gf A,G;P |- let z : Gf A be Gf x in s : B
